<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Running Order Generator - FINAL FIX</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    .generator-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #007cba;
    }
    
    .header h1 {
      color: #007cba;
      margin: 0;
    }
    
    .controls-section {
      background-color: #f0f8ff;
      border: 2px solid #007cba;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
    }
    
    .control-row {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
      align-items: end;
    }
    
    .control-group {
      flex: 1;
    }
    
    .control-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #333;
    }
    
    .control-group select,
    .control-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      text-decoration: none;
      display: inline-block;
      text-align: center;
      transition: background-color 0.3s;
    }
    
    .btn-primary {
      background-color: #007cba;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #005a8b;
    }
    
    .btn-success {
      background-color: #28a745;
      color: white;
    }
    
    .btn-success:hover {
      background-color: #218838;
    }
    
    .btn-warning {
      background-color: #ffc107;
      color: #212529;
    }
    
    .btn-warning:hover {
      background-color: #e0a800;
    }
    
    .btn-info {
      background-color: #17a2b8;
      color: white;
    }
    
    .btn-info:hover {
      background-color: #138496;
    }
    
    .btn-secondary {
      background-color: #6c757d;
      color: white;
    }
    
    .btn-secondary:hover {
      background-color: #5a6268;
    }
    
    .stats-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }
    
    .stat-number {
      font-size: 2rem;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 0.9rem;
      opacity: 0.9;
    }
    
    .running-order-section {
      margin-bottom: 30px;
    }
    
    .round-group {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      margin-bottom: 20px;
      overflow: hidden;
      page-break-inside: avoid;
    }
    
    .round-header {
      background-color: #007cba;
      color: white;
      padding: 15px;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .round-info {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .round-actions {
      display: flex;
      gap: 10px;
    }
    
    .entries-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .entries-table th {
      background-color: #f8f9fa;
      padding: 12px 8px;
      border: 1px solid #dee2e6;
      font-weight: bold;
      text-align: left;
    }
    
    .entries-table td {
      padding: 10px 8px;
      border: 1px solid #dee2e6;
      vertical-align: top;
    }
    
    .entries-table tr:nth-child(even) {
      background-color: #f8f9fa;
    }
    
    .entry-number {
      background-color: #007cba;
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      margin: 0 auto;
    }
    
    .handler-name {
      font-weight: bold;
      color: #007cba;
    }
    
    .dog-name {
      color: #333;
      margin-top: 2px;
    }
    
    .entry-type {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: bold;
    }
    
    .entry-type.regular {
      background-color: #d4edda;
      color: #155724;
    }
    
    .entry-type.feo {
      background-color: #fff3cd;
      color: #856404;
    }
    
    .actions-section {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
    }
    
    .actions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    
    .debug-section {
      background-color: #f1f3f4;
      border: 1px solid #dadce0;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
    }
    
    .debug-content {
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      font-family: monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
    
    .error {
      background-color: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    
    .success {
      background-color: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    
    @media print {
      .controls-section,
      .actions-section,
      .debug-section,
      .btn {
        display: none !important;
      }
      
      .round-group {
        page-break-inside: avoid;
        margin-bottom: 30px;
      }
      
      .round-header {
        -webkit-print-color-adjust: exact;
        color-adjust: exact;
      }
    }
  </style>
</head>
<body>
  <div class="generator-container">
    <div class="header">
      <h1>üèÉ‚Äç‚ôÇÔ∏è Running Order Generator - FINAL FIX</h1>
      <p>Generate running orders for trial rounds with proper field mapping</p>
    </div>

    <!-- Controls Section -->
    <div class="controls-section">
      <h3>üéØ Trial Selection & Settings</h3>
      
      <div class="control-row">
        <div class="control-group">
          <label for="trialSelect">Select Trial:</label>
          <select id="trialSelect">
            <option value="">Select a trial...</option>
          </select>
        </div>
        
        <div class="control-group">
          <label for="dateSelect">Select Date (Optional):</label>
          <select id="dateSelect">
            <option value="">All dates</option>
          </select>
        </div>
        
        <div class="control-group">
          <label for="sortBy">Sort Entrants By:</label>
          <select id="sortBy">
            <option value="entry">Entry Order</option>
            <option value="handler">Handler Name</option>
            <option value="dog">Dog Name</option>
            <option value="class">Class Name</option>
          </select>
        </div>
      </div>
    </div>

    <!-- Actions Section -->
    <div class="actions-section">
      <h3>‚ö° Quick Actions</h3>
      <div class="actions-grid">
        <button class="btn btn-primary" onclick="loadTrialData()">üì• Load Trial Data</button>
        <button class="btn btn-success" onclick="generateRunningOrder()">üèÉ‚Äç‚ôÇÔ∏è Generate Running Order</button>
        <button class="btn btn-warning" onclick="resetOrder()">üîÑ Reset Order</button>
        <button class="btn btn-info" onclick="printRunningOrder()">üñ®Ô∏è Print Running Order</button>
        <button class="btn btn-secondary" onclick="showDebugInfo()">üîß Debug Info</button>
        <a href="main-dashboard.html" class="btn btn-secondary">‚Üê Back to Dashboard</a>
      </div>
    </div>

    <!-- Statistics Section -->
    <div id="statsSection" class="stats-section" style="display: none;">
      <!-- Stats will be populated here -->
    </div>

    <!-- Running Order Section -->
    <div id="runningOrderSection" class="running-order-section" style="display: none;">
      <!-- Running order will be populated here -->
    </div>

    <!-- Debug Section -->
    <div id="debugSection" class="debug-section" style="display: none;">
      <h3>üîß Debug Information</h3>
      <div id="debugContent" class="debug-content"></div>
    </div>

    <!-- Loading/Error Messages -->
    <div id="loadingMessage" class="loading" style="display: none;">
      <div>Loading trial data...</div>
    </div>

    <div id="errorMessage" class="error" style="display: none;"></div>
    <div id="successMessage" class="success" style="display: none;"></div>
  </div>

  <script type="module">
    <script>
// ===========================================
// UNIVERSAL FIELD MAPPER - ADD THIS BEFORE YOUR EXISTING SCRIPT
// ===========================================

// Field aliases mapping
const FIELD_ALIASES = {
  'judge': ['judge', 'judgeName', 'judgeAssigned', 'selectedJudge', 'Judge', 'Judges Name'],
  'handler': ['handler', 'handlerName', 'Handler', 'Handler Name', 'participantName'],
  'dog': ['dog', 'dogCallName', 'dogName', 'callName', 'Call Name', 'Dog Name'],
  'class': ['class', 'className', 'Class', 'Class Name', 'classType'],
  'registration': ['registration', 'cwagsNumber', 'Registration', 'regNumber', 'registrationNumber']
};

// Smart object creator
function createSmartObject(originalObject) {
  if (!originalObject || typeof originalObject !== 'object') {
    return originalObject;
  }
  
  return new Proxy(originalObject, {
    get(target, prop) {
      const propStr = String(prop).toLowerCase();
      
      if (FIELD_ALIASES[propStr]) {
        for (const variation of FIELD_ALIASES[propStr]) {
          if (target.hasOwnProperty(variation) && target[variation] != null && target[variation] !== '') {
            return target[variation];
          }
        }
        return propStr === 'judge' ? 'Judge TBD' : 
               propStr === 'handler' ? 'Unknown Handler' :
               propStr === 'dog' ? 'Unknown Dog' :
               propStr === 'registration' ? 'No Reg' : '';
      }
      
      return target[prop];
    }
  });
}

// Universal entry processor
function processEntriesUniversally(entries) {
  console.log("üîÑ Processing entries with universal field mapping...");
  
  const processedEntries = [];
  
  entries.forEach(entryDoc => {
    if (entryDoc.selectedEntries && Array.isArray(entryDoc.selectedEntries)) {
      entryDoc.selectedEntries.forEach((selectedEntry, index) => {
        const smartSelected = createSmartObject(selectedEntry);
        const smartEntry = createSmartObject(entryDoc);
        
        const combinedEntry = createSmartObject({
          ...entryDoc,
          ...selectedEntry,
          
          // Use the smart mapping for canonical access
          judgeName: smartSelected.judge || smartEntry.judge || 'Judge TBD',
          handlerName: smartSelected.handler || smartEntry.handler || 'Unknown Handler', 
          dogCallName: smartSelected.dog || smartEntry.dog || 'Unknown Dog',
          className: smartSelected.class || 'Unknown Class',
          cwagsNumber: smartSelected.registration || smartEntry.registration || 'No Reg',
          
          entryId: entryDoc.id || `entry_${index}`,
          entryIndex: index,
          type: selectedEntry.type || 'regular'
        });
        
        processedEntries.push(combinedEntry);
      });
    }
  });
  
  console.log(`‚úÖ Processed ${processedEntries.length} entries with universal mapping`);
  return processedEntries;
}

// Override the global window functions to use smart processing
window.originalProcessEntriesUniversally = processEntriesUniversally;
</script>
    import { auth, db } from './js/firebase.js';
    import { collection, query, where, getDocs, doc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.1/firebase-firestore.js";

    // ===========================================
    // COMPREHENSIVE FIELD MAPPING - FINAL FIX
    // ===========================================
    
    // CRITICAL: Complete field mapping for all variations
    const FIELD_MAPPINGS = {
      // Handler name variations
      handlerName: ['handlerName', 'Handler', 'handler', 'Handler Name', 'participantName'],
      
      // Dog name variations  
      dogCallName: ['dogCallName', 'Call Name', 'dogName', 'callName', 'Dog Name', 'dog'],
      
      // Judge name variations
      judgeName: ['judgeName', 'judge', 'judgeAssigned', 'selectedJudge', 'Judge', 'judgeName'],
      
      // Class name variations
      className: ['className', 'Class', 'class', 'Class Name', 'classType'],
      
      // Registration variations
      cwagsNumber: ['cwagsNumber', 'Registration', 'registration', 'regNumber', 'registrationNumber']
    };

    /**
     * COMPREHENSIVE field value extractor with ALL possible field variations
     */
    function getFieldValue(obj, standardFieldName) {
      if (!obj || typeof obj !== 'object') {
        console.warn('getFieldValue: invalid object input');
        return '';
      }
      
      const possibleFields = FIELD_MAPPINGS[standardFieldName] || [standardFieldName];
      
      for (const field of possibleFields) {
        if (obj.hasOwnProperty(field) && obj[field] !== null && obj[field] !== undefined) {
          const value = String(obj[field]).trim();
          if (value && value !== 'undefined' && value !== 'null' && value !== '') {
            console.log(`‚úÖ Found ${standardFieldName} in field '${field}': "${value}"`);
            return value;
          }
        }
      }
      
      console.warn(`‚ùå No valid value found for ${standardFieldName} in:`, Object.keys(obj));
      return '';
    }

    // ===========================================
    // ENHANCED DATE UTILITIES
    // ===========================================
    
    function createLocalDate(dateInput) {
      if (!dateInput || dateInput === null || dateInput === undefined) {
        return null;
      }
      
      try {
        // Handle Firestore Timestamp objects
        if (dateInput.toDate && typeof dateInput.toDate === 'function') {
          return dateInput.toDate();
        }
        
        // Handle Date objects
        if (dateInput instanceof Date) {
          return isNaN(dateInput.getTime()) ? null : dateInput;
        }
        
        // Handle string inputs
        if (typeof dateInput === 'string') {
          let dateStr = dateInput.trim();
          if (!dateStr.includes('T') && !dateStr.includes(' ')) {
            dateStr += 'T12:00:00';
          }
          const date = new Date(dateStr);
          return isNaN(date.getTime()) ? null : date;
        }
        
        // Handle number inputs (timestamps)
        if (typeof dateInput === 'number') {
          const date = new Date(dateInput);
          return isNaN(date.getTime()) ? null : date;
        }
        
        return null;
        
      } catch (error) {
        console.error('createLocalDate error:', error);
        return null;
      }
    }

    function formatDateForDisplay(dateInput) {
      const date = createLocalDate(dateInput);
      if (!date) return 'Invalid Date';
      
      try {
        return date.toLocaleDateString('en-US', { 
          weekday: 'long',
          year: 'numeric', 
          month: 'long', 
          day: 'numeric',
          timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
        });
      } catch (error) {
        return date.toLocaleDateString();
      }
    }

    function formatDateForComparison(dateInput) {
      const date = createLocalDate(dateInput);
      if (!date) return null;
      
      try {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      } catch (error) {
        return null;
      }
    }

    function getDateFromFirebaseEntry(entry) {
      const dateFields = ['date', 'entryDate', 'trialDate', 'selectedDate'];
      
      for (const field of dateFields) {
        if (entry[field]) {
          const formattedDate = formatDateForComparison(entry[field]);
          if (formattedDate) {
            return formattedDate;
          }
        }
      }
      
      return null;
    }

    // ===========================================
    // GLOBAL VARIABLES
    // ===========================================
    let currentTrialData = null;
    let availableTrials = [];
    let allEntries = [];
    let roundsData = [];

    // ===========================================
    // COMPREHENSIVE DATA NORMALIZATION
    // ===========================================
    
    function normalizeEntryData(entry) {
      const normalized = {
        // Extract using comprehensive field mapping
        handlerName: getFieldValue(entry, 'handlerName'),
        dogCallName: getFieldValue(entry, 'dogCallName'),
        className: getFieldValue(entry, 'className'),
        judgeName: getFieldValue(entry, 'judgeName'),
        cwagsNumber: getFieldValue(entry, 'cwagsNumber'),
        
        // Preserve all original fields
        ...entry
      };
      
      // Fallback for judge names that might be "TBD" or empty
      if (!normalized.judgeName || normalized.judgeName === 'TBD' || normalized.judgeName === 'Judge TBD') {
        normalized.judgeName = 'Judge TBD';
      }
      
      console.log('üìù Normalized entry:', {
        handler: normalized.handlerName,
        dog: normalized.dogCallName,
        class: normalized.className,
        judge: normalized.judgeName,
        reg: normalized.cwagsNumber
      });
      
      return normalized;
    }

    // ===========================================
    // TRIAL DATA LOADING
    // ===========================================
    async function loadAvailableTrials() {
      try {
        console.log("üîç Loading available trials...");
        
        const trialsQuery = query(
          collection(db, 'trials'),
          where('createdBy', '==', auth.currentUser.uid)
        );
        
        const trialsSnapshot = await getDocs(trialsQuery);
        availableTrials = [];
        
        trialsSnapshot.forEach(doc => {
          const trialData = doc.data();
          
          // Process trial dates properly
          if (trialData.days && Array.isArray(trialData.days)) {
            trialData.days = trialData.days.map(day => ({
              ...day,
              date: formatDateForComparison(day.date)
            })).filter(day => day.date !== null);
          }
          
          availableTrials.push({
            id: doc.id,
            ...trialData
          });
        });
        
        populateTrialDropdown();
        console.log("‚úÖ Loaded trials:", availableTrials.length);
        
      } catch (error) {
        console.error("‚ùå Error loading trials:", error);
        showError("Error loading trials: " + error.message);
      }
    }

    function populateTrialDropdown() {
      const trialSelect = document.getElementById('trialSelect');
      trialSelect.innerHTML = '<option value="">Select a trial...</option>';

      availableTrials.forEach(trial => {
        const option = document.createElement('option');
        option.value = trial.id;
        
        let label = trial.clubName || 'Unnamed Trial';
        if (trial.days && trial.days.length > 0) {
          const firstDate = trial.days[0].date;
          if (firstDate) {
            label += ` - ${firstDate}`;
          }
        }
        
        option.textContent = label;
        trialSelect.appendChild(option);
      });

      // Auto-select if only one trial
      if (availableTrials.length === 1) {
        trialSelect.value = availableTrials[0].id;
      }
    }

    async function loadTrialData() {
      const trialId = document.getElementById('trialSelect').value;
      if (!trialId) {
        showError("Please select a trial first.");
        return;
      }

      try {
        showLoading(true);
        console.log("üì• Loading trial data for:", trialId);

        // Load trial structure
        currentTrialData = availableTrials.find(t => t.id === trialId);
        if (!currentTrialData) {
          const trialDoc = await getDoc(doc(db, 'trials', trialId));
          if (!trialDoc.exists()) {
            throw new Error('Trial not found');
          }
          currentTrialData = { id: trialDoc.id, ...trialDoc.data() };
          
          // Process dates
          if (currentTrialData.days) {
            currentTrialData.days = currentTrialData.days.map(day => ({
              ...day,
              date: formatDateForComparison(day.date)
            })).filter(day => day.date !== null);
          }
        }

        // Load entries
        await loadTrialEntries(trialId);
        
        // Process rounds with COMPREHENSIVE deduplication
        processRoundsDataWithDeduplication();
        
        // Update UI
        populateDateDropdown();
        updateStatistics();
        
        showSuccess(`Loaded ${allEntries.length} entries from ${currentTrialData.clubName}`);
        
      } catch (error) {
        console.error("‚ùå Error loading trial data:", error);
        showError("Error loading trial data: " + error.message);
      } finally {
        showLoading(false);
      }
    }

    async function loadTrialEntries(trialId) {
      try {
        console.log("üìä Loading entries for trial:", trialId);
        
        const entriesQuery = query(
          collection(db, 'entries'),
          where('trialId', '==', trialId)
        );
        
        const entriesSnapshot = await getDocs(entriesQuery);
        allEntries = [];
        
        entriesSnapshot.forEach(doc => {
          const entryDoc = doc.data();
          console.log("üìÑ Processing entry document:", doc.id);
          
          if (entryDoc.selectedEntries && Array.isArray(entryDoc.selectedEntries)) {
            entryDoc.selectedEntries.forEach((selectedEntry, index) => {
              // COMPREHENSIVE normalization of BOTH document AND selected entry
              const baseEntry = normalizeEntryData(entryDoc);
              const selectedNormalized = normalizeEntryData(selectedEntry);
              
              const combinedEntry = {
                // Merge base entry data with selected entry data
                ...baseEntry,
                ...selectedNormalized,
                
                // Ensure we have all critical fields with fallbacks
                handlerName: selectedNormalized.handlerName || baseEntry.handlerName || 'Unknown Handler',
                dogCallName: selectedNormalized.dogCallName || baseEntry.dogCallName || 'Unknown Dog',
                className: selectedNormalized.className || 'Unknown Class',
                judgeName: selectedNormalized.judgeName || 'Judge TBD',
                cwagsNumber: selectedNormalized.cwagsNumber || baseEntry.cwagsNumber || 'No Reg',
                
                // Entry metadata
                entryId: doc.id,
                entryIndex: index,
                date: getDateFromFirebaseEntry(selectedEntry),
                roundNumber: selectedEntry.roundNumber || 1,
                type: selectedEntry.type || 'regular'
              };
              
              // Only add entries with valid dates and essential data
              if (combinedEntry.date && combinedEntry.className && combinedEntry.handlerName) {
                allEntries.push(combinedEntry);
                console.log("‚úÖ Added entry:", {
                  handler: combinedEntry.handlerName,
                  dog: combinedEntry.dogCallName,
                  class: combinedEntry.className,
                  judge: combinedEntry.judgeName,
                  date: combinedEntry.date
                });
              } else {
                console.warn("‚ùå Skipping incomplete entry:", combinedEntry);
              }
            });
          }
        });
        
        console.log("‚úÖ Loaded valid entries:", allEntries.length);
        
      } catch (error) {
        console.error("‚ùå Error loading entries:", error);
        throw error;
      }
    }

    // ===========================================
    // ENHANCED ROUNDS PROCESSING WITH DEDUPLICATION
    // ===========================================
    
    function processRoundsDataWithDeduplication() {
      console.log("üîÑ Processing rounds with comprehensive deduplication...");
      
      roundsData = [];
      const roundsMap = new Map();

      allEntries.forEach(entry => {
        // Create SMARTER round key that avoids TBD duplicates
        const cleanJudgeName = (entry.judgeName && entry.judgeName !== 'Judge TBD' && entry.judgeName !== 'TBD') 
          ? entry.judgeName 
          : 'Judge TBD';
          
        const roundKey = `${entry.date}_${entry.className}_${entry.roundNumber}_${cleanJudgeName}`;
        
        // Skip if we already have this round with a proper judge name
        if (roundsMap.has(roundKey)) {
          const existingRound = roundsMap.get(roundKey);
          
          // If existing round has TBD judge and new entry has real judge, replace
          if (existingRound.judgeName === 'Judge TBD' && cleanJudgeName !== 'Judge TBD') {
            console.log("üîÑ Replacing TBD judge with real judge:", cleanJudgeName);
            existingRound.judgeName = cleanJudgeName;
          }
          
          existingRound.entries.push(entry);
        } else {
          // Create new round
          roundsMap.set(roundKey, {
            date: entry.date,
            dateDisplay: formatDateForDisplay(entry.date),
            className: entry.className,
            roundNumber: entry.roundNumber,
            judgeName: cleanJudgeName,
            entries: [entry]
          });
        }
      });

      // Convert to array and sort
      roundsData = Array.from(roundsMap.values()).sort((a, b) => {
        if (a.date !== b.date) return new Date(a.date) - new Date(b.date);
        if (a.className !== b.className) return a.className.localeCompare(b.className);
        return a.roundNumber - b.roundNumber;
      });

      // Sort entries within each round
      roundsData.forEach(round => {
        const sortBy = document.getElementById('sortBy').value;
        round.entries.sort((a, b) => {
          switch (sortBy) {
            case 'handler': return a.handlerName.localeCompare(b.handlerName);
            case 'dog': return a.dogCallName.localeCompare(b.dogCallName);
            case 'class': return a.className.localeCompare(b.className);
            default: return 0; // entry order
          }
        });
      });

      console.log("‚úÖ Processed unique rounds:", roundsData.length);
      console.log("üìä Sample round data:", roundsData.slice(0, 2));
    }

    function populateDateDropdown() {
      const dateSelect = document.getElementById('dateSelect');
      dateSelect.innerHTML = '<option value="">All dates</option>';

      if (currentTrialData && currentTrialData.days) {
        currentTrialData.days.forEach(day => {
          if (day.date) {
            const option = document.createElement('option');
            option.value = day.date;
            option.textContent = formatDateForDisplay(day.date);
            dateSelect.appendChild(option);
          }
        });
      }
    }

    function updateStatistics() {
      const totalEntries = allEntries.length;
      const uniqueHandlers = new Set(allEntries.map(e => e.handlerName)).size;
      const uniqueClasses = new Set(allEntries.map(e => e.className)).size;
      const uniqueJudges = new Set(allEntries.map(e => e.judgeName).filter(j => j !== 'Judge TBD')).size;

      const statsHTML = `
        <div class="stat-card">
          <div class="stat-number">${totalEntries}</div>
          <div class="stat-label">Total Entries</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">${uniqueHandlers}</div>
          <div class="stat-label">Handlers</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">${uniqueClasses}</div>
          <div class="stat-label">Classes</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">${uniqueJudges}</div>
          <div class="stat-label">Judges</div>
        </div>
      `;

      document.getElementById('statsSection').innerHTML = statsHTML;
      document.getElementById('statsSection').style.display = 'grid';
    }

    function generateRunningOrder() {
      if (roundsData.length === 0) {
        showError("No rounds data available. Please load trial data first.");
        return;
      }

      const selectedDate = document.getElementById('dateSelect').value;
      const filteredRounds = selectedDate 
        ? roundsData.filter(round => round.date === selectedDate)
        : roundsData;

      console.log("üèÉ‚Äç‚ôÇÔ∏è Generating running order for", filteredRounds.length, "rounds");

      let runningOrderHTML = '';
      
      filteredRounds.forEach((round, roundIndex) => {
        console.log(`Round ${roundIndex + 1}:`, round.className, "Judge:", round.judgeName, "Entries:", round.entries.length);
        
        const entriesHTML = round.entries.map((entry, entryIndex) => {
          console.log(`  Entry ${entryIndex + 1}:`, {
            handler: entry.handlerName,
            dog: entry.dogCallName,
            reg: entry.cwagsNumber,
            type: entry.type
          });
          
          return `
            <tr>
              <td style="text-align: center; width: 60px;">
                <div class="entry-number">${entryIndex + 1}</div>
              </td>
              <td>
                <div class="handler-name">${entry.handlerName || 'Unknown Handler'}</div>
                <div class="dog-name">${entry.dogCallName || 'Unknown Dog'}</div>
              </td>
              <td style="text-align: center; width: 80px;">
                <span class="entry-type ${entry.type || 'regular'}">${entry.type === 'feo' ? 'FEO' : 'REG'}</span>
              </td>
              <td style="width: 120px;">${entry.cwagsNumber || 'No Reg'}</td>
              <td style="width: 100px; border-right: 2px solid #000;"></td>
              <td style="width: 100px;"></td>
            </tr>
          `;
        }).join('');

        runningOrderHTML += `
          <div class="round-group">
            <div class="round-header">
              <div class="round-info">
                <span><strong>${round.className} - Round ${round.roundNumber}</strong></span>
                <span>Judge: ${round.judgeName}</span>
                <span>${round.dateDisplay}</span>
                <span>${round.entries.length} entries</span>
              </div>
            </div>
            <table class="entries-table">
              <thead>
                <tr>
                  <th style="width: 60px; text-align: center;">#</th>
                  <th>Handler & Dog</th>
                  <th style="width: 80px; text-align: center;">Type</th>
                  <th style="width: 120px;">Registration</th>
                  <th style="width: 100px; border-right: 2px solid #000;">Time</th>
                  <th style="width: 100px;">Score</th>
                </tr>
              </thead>
              <tbody>
                ${entriesHTML}
              </tbody>
            </table>
          </div>
        `;
      });

      document.getElementById('runningOrderSection').innerHTML = runningOrderHTML;
      document.getElementById('runningOrderSection').style.display = 'block';

      showSuccess(`Generated running order for ${filteredRounds.length} rounds with complete handler/dog information`);
    }

    // ===========================================
    // UTILITY FUNCTIONS
    // ===========================================
    function resetOrder() {
      document.getElementById('runningOrderSection').style.display = 'none';
      document.getElementById('statsSection').style.display = 'none';
      allEntries = [];
      roundsData = [];
      showSuccess("Order reset successfully");
    }

    function printRunningOrder() {
      const runningOrderSection = document.getElementById('runningOrderSection');
      if (runningOrderSection.style.display === 'none') {
        showError("Please generate running order first.");
        return;
      }
      
      window.print();
    }

    function showDebugInfo() {
      const debugContent = document.getElementById('debugContent');
      const debugSection = document.getElementById('debugSection');
      
      const debugInfo = {
        currentTrialData: currentTrialData,
        totalTrials: availableTrials.length,
        totalEntries: allEntries.length,
        totalRounds: roundsData.length,
        fieldMappings: FIELD_MAPPINGS,
        sampleEntries: allEntries.slice(0, 3).map(entry => ({
          handlerName: entry.handlerName,
          dogCallName: entry.dogCallName,
          className: entry.className,
          judgeName: entry.judgeName,
          cwagsNumber: entry.cwagsNumber,
          date: entry.date,
          type: entry.type,
          originalFields: Object.keys(entry).filter(key => !['handlerName', 'dogCallName', 'className', 'judgeName', 'cwagsNumber'].includes(key))
        })),
        sampleRounds: roundsData.slice(0, 3).map(round => ({
          ...round,
          entries: round.entries.slice(0, 2)
        }))
      };
      
      debugContent.textContent = JSON.stringify(debugInfo, null, 2);
      debugSection.style.display = debugSection.style.display === 'none' ? 'block' : 'none';
    }

    function showLoading(show) {
      document.getElementById('loadingMessage').style.display = show ? 'block' : 'none';
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorMessage');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      setTimeout(() => errorDiv.style.display = 'none', 5000);
    }

    function showSuccess(message) {
      const successDiv = document.getElementById('successMessage');
      successDiv.textContent = message;
      successDiv.style.display = 'block';
      setTimeout(() => successDiv.style.display = 'none', 3000);
    }

    // ===========================================
    // EVENT LISTENERS
    // ===========================================
    document.addEventListener('DOMContentLoaded', function() {
      // Add event listeners for dropdowns
      document.getElementById('dateSelect').addEventListener('change', function() {
        if (roundsData.length > 0) {
          generateRunningOrder();
        }
      });

      document.getElementById('sortBy').addEventListener('change', function() {
        if (roundsData.length > 0) {
          processRoundsDataWithDeduplication();
          generateRunningOrder();
        }
      });

      // Initial setup
      document.getElementById('debugSection').style.display = 'none';
    });

    // ===========================================
    // GLOBAL FUNCTIONS
    // ===========================================
    window.loadTrialData = loadTrialData;
    window.generateRunningOrder = generateRunningOrder;
    window.resetOrder = resetOrder;
    window.printRunningOrder = printRunningOrder;
    window.showDebugInfo = showDebugInfo;

    // ===========================================
    // AUTHENTICATION AND INITIALIZATION
    // ===========================================
    auth.onAuthStateChanged(async (user) => {
      if (user) {
        console.log("‚úÖ User authenticated:", user.email);
        try {
          await loadAvailableTrials();
        } catch (error) {
          console.error("‚ùå Error during initialization:", error);
          showError("Error loading initial data: " + error.message);
        }
      } else {
        console.log("‚ùå No user authenticated, redirecting to login");
        window.location.href = 'index.html';
      }
    });

    // ===========================================
    // DEBUG HELPERS
    // ===========================================
    window.debugRunningOrder = {
      allEntries: () => allEntries,
      roundsData: () => roundsData,
      currentTrialData: () => currentTrialData,
      FIELD_MAPPINGS: FIELD_MAPPINGS,
      getFieldValue: getFieldValue,
      normalizeEntryData: normalizeEntryData,
      testFieldExtraction: (entry) => {
        console.log("Testing field extraction for entry:", entry);
        return {
          handlerName: getFieldValue(entry, 'handlerName'),
          dogCallName: getFieldValue(entry, 'dogCallName'),
          className: getFieldValue(entry, 'className'),
          judgeName: getFieldValue(entry, 'judgeName'),
          cwagsNumber: getFieldValue(entry, 'cwagsNumber')
        };
      }
    };

    console.log("‚úÖ FINAL FIX Running Order Generator loaded with comprehensive field mapping");
    console.log("üîß Debug tools available at window.debugRunningOrder");
  </script>
</body>
</html>
